<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Bytemaster&#39;s Boost Libraries: Quick Start</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Quick Start<br/>
<small>
[<a class="el" href="group__boost__reflect.html">Boost.Reflect</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
</table>
<p>There are two primary uses for the Boost.Reflect library:</p>
<ul>
<li>Visiting members on a type.</li>
<li>Creating type erasures for an interface</li>
</ul>
<h2><a class="anchor" id="boost_reflect_basic">
Basic Reflection</a></h2>
<p>Basic reflection of a type is achieved using the <a class="el" href="reflect_8hpp.html#a90309261db059f46860d655ed351013d">BOOST_REFLECT(TYPE,INHERITS,MEMBERS)</a> macro to specify base classes and class members. Below is an example of reflecting a struct.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">struct </span>my_struct {
        <span class="keywordtype">int</span>         hello;
        std::string world;
    };
    <a class="code" href="reflect_8hpp.html#a90309261db059f46860d655ed351013d" title="Specializes boost::reflect::reflector for TYPE.">BOOST_REFLECT</a>( my_struct, (hello)(world) )
</pre></div><p>Now that we have reflected the struct, we can dump it to XML with a simple visitor.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
    <span class="keyword">struct </span>xml_printer {
        xml_printer( <span class="keyword">const</span> T&amp; c ):self(c){}

        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt; 
        <span class="keyword">static</span> xml_printer&lt;Type&gt; make( <span class="keyword">const</span> Type&amp; t ) {
            <span class="keywordflow">return</span> xml_printer&lt;Type&gt;(t);
        }

        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Class, <span class="keyword">typename</span> Member&gt;
        <span class="keywordtype">void</span> operator()( Member Class::*p, <span class="keyword">const</span> <span class="keywordtype">char</span>* name )<span class="keyword">const </span>{
            std::cerr&lt;&lt;<span class="stringliteral">&quot;&lt;&quot;</span>&lt;&lt;name&lt;&lt;<span class="stringliteral">&quot;&gt;&quot;</span>&lt;&lt;(<span class="keyword">self</span>.*p)&lt;&lt;<span class="stringliteral">&quot;&lt;/&quot;</span>&lt;&lt;name&lt;&lt;<span class="stringliteral">&quot;&gt;\n&quot;</span>;
        }
        <span class="keyword">const</span> T&amp; <span class="keyword">self</span>;
    };
</pre></div><p>The visitor can then be applied like so: </p>
<div class="fragment"><pre class="fragment">        my_struct s;
        <a class="code" href="structboost_1_1reflect_1_1reflector.html" title="defines visit functions for T Unless this is specialized, visit() will not be defined...">boost::reflect::reflector&lt;my_struct&gt;::visit</a>( xml_printer&lt;my_struct&gt;(s) );
        <a class="code" href="structboost_1_1reflect_1_1reflector.html" title="defines visit functions for T Unless this is specialized, visit() will not be defined...">boost::reflect::reflector&lt;my_struct&gt;::visit</a>( xml_printer::make(s) );
</pre></div><h2><a class="anchor" id="boost_reflect_erasures">
Type Erasures</a></h2>
<p>Type Erasure is one means to hide implementation details by defining a type that can contain any object that implements the required interface. Examples are boost::any and boost::function. Boost.Reflect enables the rapid generation of new type erasures for arbitrary interfaces via the <a class="el" href="classboost_1_1reflect_1_1any__ptr.html">any_ptr&lt;Interface&gt; </a> type.</p>
<p><a class="el" href="classboost_1_1reflect_1_1any__ptr.html" title="Behaves like a smart pointer that can handle any type with the same interface.">boost::reflect::any_ptr</a> can hold a pointer or shared pointer to any type that implements a particular reflected interface.</p>
<p>Here is an example on how to define a new type erasure for two interfaces, Service and Calculator.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">struct </span>Service {
      std::string name()<span class="keyword">const</span>;
      <span class="keywordtype">int</span>         exit();
    };
    <span class="keyword">struct </span>Calculator : Service {
      <span class="keywordtype">double</span> add( <span class="keywordtype">double</span> v );           
      <span class="keywordtype">double</span> sub( <span class="keywordtype">double</span> v );           
      <span class="keywordtype">double</span> mult( <span class="keywordtype">double</span> v );           
      <span class="keywordtype">double</span> div( <span class="keywordtype">double</span> v );           
      <span class="keywordtype">double</span> result()<span class="keyword">const</span>;
    };

    BOOST_REFLECT_ANY( Service,(name)(exit) )
    BOOST_REFLECT_ANY_DERIVED( Calculator, (Service), (add)(sub)(mult)(div)(result) )
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>When you define an interface, you need not provide implementations of the methods; however, if you want you may also use an interace like any other class without limititations.</dd></dl>
<div class="fragment"><pre class="fragment">    <span class="keyword">class </span>CalculatorService {
      <span class="keyword">public</span>:
        CalculatorService():m_result(0){}

        std::string name()<span class="keyword">const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;CalculatorService&quot;</span>; }
        <span class="keywordtype">int</span>   exit()            { ::exit(0);                  }
        <span class="keywordtype">double</span> add( <span class="keywordtype">double</span> v )  { <span class="keywordflow">return</span> m_result += v;       }
        <span class="keywordtype">double</span> sub( <span class="keywordtype">double</span> v )  { <span class="keywordflow">return</span> m_result -= v;       }
        <span class="keywordtype">double</span> mult( <span class="keywordtype">double</span> v ) { <span class="keywordflow">return</span> m_result *= v;       }
        <span class="keywordtype">double</span> div( <span class="keywordtype">double</span> v )  { <span class="keywordflow">return</span> m_result /= v;       }
        <span class="keywordtype">double</span> result()<span class="keyword">const    </span>{ <span class="keywordflow">return</span> m_result;            }

      <span class="keyword">private</span>:
        <span class="keywordtype">double</span> m_result;
    };

    <span class="keywordtype">void</span> try_it() {
      reflect::any_ptr&lt;Calculator&gt; calc( <span class="keyword">new</span> CalculatorService() );
      calc-&gt;add(5);
      calc-&gt;add(6);
      std::string name = calc-&gt;name();
      assert( calc-&gt;result() == 11 );
    }
</pre></div><p>Some things to note, CalculatorService did not inherit either Calculator or Service, it simply exposed all of the methods defined by the interface. If it looks like a Duck, quacks like a Duck, then it is a Duck.</p>
<p>The interface of any_ptr&lt;Calculator&gt; is 'identical' to the Calculator defined above.</p>
<p>Pointer semantics were chosen to discourage using reflect::anys as values where assignment and copy construction creates a new instance. Initialization of <a class="el" href="classboost_1_1reflect_1_1any__ptr.html">any_ptr </a> with a new pointer is a relatively expensive operation and value semantics would create objects that are much bigger and more expensive to copy than traditional types as each method is a functor that must be initialized at copy/construction time.</p>
<p>Generally speaking, any_ptr&lt;&gt; should be used to abstract long-lived objects and not for temporaries. </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<script type="text/javascript">

  var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-2423876-2']);
      _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
                      })();

                      </script>
